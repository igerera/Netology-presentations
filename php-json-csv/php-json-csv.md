# PHP. Работа с файлами. Json. CSV

## Форматы DSV и JSON
### DSV
**DSV (delimiter separated values)** - текстовый формат, в котором данные разделены специальными символами. Данный формат предназначен для представления табличных данных. 

Каждая строка - отдельная запись в таблице. 

В зависимости от разделителя существуют разные форматы *CSV* и *TSV* с разделителем запятая (comma) и табуляция соответственно. 

В DSV первой строкой может идти перечисление названий столбцов.

Все значения хранятся как строки и тип значения определяется непосредственно в коде.

### JSON
**JSON (JavaScript Object Notation)** - текстовый формат, в котором данные описаны примитивами языка JS:

* null
* булево (true / false)
* число
* строка
* массив примитивов
* объект с ключами строками и значениями примитивами

Несмотря на происхождение от JavaScript (точнее, от подмножества языка стандарта 1999 года), формат считается независимым от языка и может использоваться практически с любым языком программирования. Для многих языков, в том числе PHP, существует готовый код для создания и обработки данных в формате JSON.

## Удаленные ресурсы 
Содержимое страниц в интернете также является текстовыми данными и к ним тоже можно обращаться. 
Например, вызов удаленного апи https://samples.openweathermap.org/data/2.5/weather?q=London,uk&appid=b6907d289e10d714a6e88b30761fae22 для получения погоды с сайта openweather вернет json. 

Отличие таких ресурсов, что в них нельзя записать данные как на файловую систему.

## Работа с файловой системой
Во всех функциях (если не оговорено иначе) первый аргумент - путь к файлу.

### Простейшие функции
#### Функция file
Функция `file()` читает содержимое файла и помещает его в массив. 

Каждый элемент массива соответствует строке файла, с символами новой строки включительно. 

В случае ошибки `file()` возвращает FALSE.

Вторым параметром можно указать специальные флаги:
* FILE_USE_INCLUDE_PATH - ищет файл в include_path
* FILE_IGNORE_NEW_LINES - пропускать новую строку в конце каждого элемента массива
* FILE_SKIP_EMPTY_LINES - пропускать пустые строки
```php
// Используем необязательный параметр flags (начиная с PHP 5)
$trimmed = file('somefile.txt', FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
```
#### Функция file_get_contents
Функция `file_get_contents()` читает содержимое файла в строку. 

Использование функции `file_get_contents()` наиболее предпочтительно в случае необходимости получить содержимое файла целиком, поскольку для улучшения производительности функция использует технику отображения файла в память (memory mapping), если она поддерживается вашей операционной системой.

В случае неудачи функция `file_get_contents()`  вернёт `FALSE`.
```php
$homepage = file_get_contents('http://www.example.com/');
```

#### Функция file_put_contents
Функция `file_put_contents()` записывает данные в файл. 

Если файл не существует, то он будет создан. Иначе существующий файл будет перезаписан.

Второй аргумент - данные для записи - могут представлять собой строку, массив и поток. В случае массива все элементы будут склеены без разделителя. Если данные являются потоковым ресурсом (stream), оставшийся буфер этого потока будет скопирован в указанный файл.

Третьим аргументом можно указать специальные флаги:
* FILE_USE_INCLUDE_PATH	- ищет filename в подключаемых директориях
* FILE_APPEND - если файл filename уже существует, данные будут дописаны в конец файла вместо того, чтобы его перезаписать
* LOCK_EX - получить эксклюзивную блокировку на файл на время записи. Другими словами, между вызовами fopen() и fwrite() произойдет вызов функции flock()

*Простой пример с использованием `file_get_contents()`*
```php
$file = 'people.txt';
// Открываем файл для получения существующего содержимого
$current = file_get_contents($file);
// Добавляем нового человека в файл
$current .= "John Smith\n";
// Пишем содержимое обратно в файл
file_put_contents($file, $current);
```
*Пример с использованием флагов*
```php
$file = 'people.txt';
// Новый человек, которого нужно добавить в файл
$person = "John Smith\n";
// Пишем содержимое в файл, используя флаг FILE_APPEND для дописывания 
// содержимого в конец файла и флаг LOCK_EX для предотвращения записи 
// данного файла кем-нибудь другим в данное время
file_put_contents($file, $person, FILE_APPEND | LOCK_EX);
```
### Ресурсы для работы с файлом
#### Функция fopen
Функция `fopen()` создает именованный ресурс для работы с файлом

Вторым параметром нужно указать режим работы с файлом. Самыми распространенными являются:
* **r** - Открывает файл только для чтения; помещает указатель в начало файла.
* **r+** - Открывает файл для чтения и записи; помещает указатель в начало файла.
* **w** - Открывает файл только для записи; помещает указатель в начало файла и обрезает файл до нулевой длины. Если файл не существует - пробует его создать.
* **w+** - Открывает файл для чтения и записи; помещает указатель в начало файла и обрезает файл до нулевой длины. Если файл не существует - пытается его создать.
* **a** - Открывает файл только для записи; помещает указатель в конец файла. Если файл не существует - пытается его создать. 
* **a+** - Открывает файл для чтения и записи; помещает указатель в конец файла. Если файл не существует - пытается его создать. 

Windows предлагает флаг режима текстовой трансляции (**t**), который автоматически переводит `\n` в `\r\n` во время работы с файлом. 

И наоборот - вы также можете использовать **b**, чтобы принудительно включить бинарный режим, в котором ваши данные не будут преобразовываться. Чтобы использовать эти режимы, укажите 'b' или 't' последней буквой параметра.
```php
$handle = fopen("/home/netology/data.txt", "ab");
```
#### Функция fclose
Функция `fclose()` закрывает ресурс, связанный с файлом через `fopen`

#### Функция fread
Функция `fread()` предназначена для бинарно-безопасного чтения из ресурса, открытого с помощью fopen. Причем файл должен быть открыт с флагом b на системах, которые различают текстовые и бинарные форматы файлов (например Windows)


Первый аргумент - ресурс.
Вторым аргументом указывается количество байт, которые нужно считать. 

Чтение останавливается как только было достигнуто одно из следующих условий:
* было прочитано length байт
* достигнут EOF (конец файла)
* стал доступен пакет или произошел тайм-аут сокета (для сетевых потоков)
* если читаемый поток является буферизованным и не представляет собой обычный файл, то за один раз максимум читается количество байт, равное размеру одной порции данных (обычно это 8192), однако, в зависимости от ранее буферизованных данных, размер возвращаемых данных может быть больше размера одной порции данных.

```php
$filename = "/usr/local/something.txt";
$handle = fopen($filename, "r");
$contents = fread($handle, filesize($filename));
fclose($handle);
```

#### Фукнция fwrite
Функция `fwrite()` предназначена для бинарно-безопасной записи в ресурс, открытый с помощью fopen. Причем файл должен быть открыт с флагом b на системах, которые различают текстовые и бинарные форматы файлов (например Windows)

Первый аргумент - ресурс.
Второй аргумент - строка.

Третьим аргументом можно передать количество данных, которые должны быть записаны. Если строка содержит меньше данных, чем указано, то запись закончится, когда вся строка будет записана.

При повторной записи в файловый ресурс, данные будут добавлены в конец содержимого файла
```php
$fp = fopen('data.txt', 'w');
fwrite($fp, '1');
fwrite($fp, '23'); // данные будут дописаны
fclose($fp);

// содержимое 'data.txt' теперь 123, а не 23!
```

### Работа с CSV
#### Функция fgetcsv
Функция `fgetcsv()` читает строку из файла, производит разбор данных CSV и возвращает индексированный массив с прочитанными полями.

Параметры функции:
* handle - корректный файловый указатель на файл, успешно открытый при помощи fopen()
* length - должен быть больше самой длинной строки (в символах), найденной в CSV-файле (включая завершающий символ конца строки). В противном случае, строка будет разбита на куски длиной в length символов, если только место разрыва не будет внутри ограничителей полей (enclosure). Отсутствие этого параметра (или установка его в 0 в PHP 5.1.0 и выше) приведет к тому, что длина строки будет неограничена. Это может сказаться на скорости выполнения
* delimiter - необязательный параметр delimiter устанавливает разделитель поля (только один символ)

```php
$row = 1;
$handle = fopen("test.csv", "r");
if ($handle !== FALSE) {
    $data = fgetcsv($handle, 1000, ",");
    while ($data !== FALSE) {
        $num = count($data);
        echo "<p> $num полей в строке $row:</p>\n";
        $row++;
        for ($c=0; $c < $num; $c++) {
            echo $data[$c] . "<br />\n";
        }
    }
    fclose($handle);
}
```
#### Функция fputcsv
Функция `fputcsv()` форматирует строку (переданную в виде массива fields) в виде CSV и записывает её (заканчивая переводом строки) в указанный файл.

Параметры функции:
* handle - указатель на файл должен быть корректным и указывать на файл, успешно открытый функциями fopen()
* fields - массив строк (string).
* delimiter - дополнительный параметр delimiter устанавливает разделитель полей (только один символ)
```php
$list = array (
    array('aaa', 'bbb', 'ccc', 'dddd'),
    array('123', '456', '789'),
    array('"aaa"', '"bbb"')
);

$fp = fopen('file.csv', 'w');

foreach ($list as $fields) {
    fputcsv($fp, $fields);
}

fclose($fp);
/* Содержимое файла file.csv
aaa,bbb,ccc,dddd
123,456,789
"""aaa""","""bbb"""
*/
```
### Функции работы с JSON
#### Функция json_decode 
Функция `json_decode()` декодирует строку JSON.

Данная функция применяется для разбора строки в php-переменную.
По умолчанию объекты json преобразуются в `StdClass`
```php
$json = '{"a":1,"b":2,"c":3,"d":4,"e":5}';
$parsed = json_decode($json);
var_dump($parsed);
/*
object(stdClass)#1 (5) {
    ["a"] => int(1)
    ["b"] => int(2)
    ["c"] => int(3)
    ["d"] => int(4)
    ["e"] => int(5)
}
*/
```
Если вторым аргументом передать true, то объекты будут преобразованы в ассоциативные массивы
```php
$parsed = json_decode($json, true);
var_dump($parsed);
/*
array(5) {
    ["a"] => int(1)
    ["b"] => int(2)
    ["c"] => int(3)
    ["d"] => int(4)
    ["e"] => int(5)
}
*/
```
#### Функция json_encode
Функция `json_encode()` преобразует значение переменной php в JSON строку.

Пример сохранения в файл
```php
$arr = array('a' => 1, 'b' => 2, 'c' => '3' );
file_put_contents("./numbers.json", json_encode($arr));
// в файле numbers.json будет {"a": 1, "b": 2, "c": "3"}
```
#### Функция json_last_error_msg
Функция `json_last_error_msg()` возвращает сообщение об ошибке в случае успешного выполнения, `"No error"`, если ошибки не произошло, или `FALSE` в случае возникновения ошибки после вызова `json_encode()` или `json_decode()`.
#### Функция json_last_error 
Функция `json_last_error()` возвращает целочисленное значение, которое может быть одной из следующих констант:

* JSON_ERROR_NONE - Ошибок нет
* JSON_ERROR_DEPTH - Достигнута максимальная глубина стека
* JSON_ERROR_STATE_MISMATCH - Неверный или некорректный JSON
* JSON_ERROR_CTRL_CHAR - Ошибка управляющего символа, возможно неверная кодировка
* JSON_ERROR_SYNTAX - Синтаксическая ошибка
* JSON_ERROR_UTF8 - Некорректные символы UTF-8, возможно неверная кодировка
* JSON_ERROR_RECURSION - Одна или несколько зацикленных ссылок в кодируемом значении
* JSON_ERROR_INF_OR_NAN - Одно или несколько значений NAN или INF в кодируемом значении
* JSON_ERROR_UNSUPPORTED_TYPE - Передано значение с неподдерживаемым типом
* JSON_ERROR_INVALID_PROPERTY_NAME - Имя свойства не может быть закодировано
* JSON_ERROR_UTF16 - Некорректный символ UTF-16, возможно некорректно закодирован


*Пример использования:*
```php
// Верная json-строка
$json[] = '{"Organization": "PHP Documentation Team"}';
// Неверная json-строка, которая вызовет синтаксическую ошибку,
// здесь в качестве кавычек мы используем ' вместо "
$json[] = "{'Organization': 'PHP Documentation Team'}";
foreach ($json as $string) {
    echo 'Декодируем: ' . $string;
    json_decode($string);

    switch (json_last_error()) {
        case JSON_ERROR_NONE:
            echo ' - Ошибок нет';
        break;
        case JSON_ERROR_DEPTH:
            echo ' - Достигнута максимальная глубина стека';
        break;
        case JSON_ERROR_STATE_MISMATCH:
            echo ' - Некорректные разряды или несоответствие режимов';
        break;
        case JSON_ERROR_CTRL_CHAR:
            echo ' - Некорректный управляющий символ';
        break;
        case JSON_ERROR_SYNTAX:
            echo ' - Синтаксическая ошибка, некорректный JSON';
        break;
        case JSON_ERROR_UTF8:
            echo ' - Некорректные символы UTF-8, возможно неверно закодирован';
        break;
        default:
            echo ' - Неизвестная ошибка';
        break;
    }

    echo PHP_EOL;
}
```
*Результат выполнения:*
```
Декодируем: {"Organization": "PHP Documentation Team"} - Ошибок нет
Декодируем: {'Organization': 'PHP Documentation Team'} - Синтаксическая ошибка, некорректный JSON
```


Для чтения и записи json в файлы используются стандартные функции, рассмотренные выше